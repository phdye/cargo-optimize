//! Boundary value tests for edge cases

use cargo_optimize::{Config, OptimizationLevel, analyzer::*, detector::*, optimizer::*};
use std::path::{Path, PathBuf};
use tempfile::TempDir;
use std::fs;

#[test]
fn boundary_empty_config() {
    // Test with completely empty/minimal config
    let config = Config::new();
    
    // Should have sensible defaults
    assert_eq!(config.optimization_level, OptimizationLevel::Balanced);
    assert!(config.auto_detect_hardware);
    assert!(config.analyze_project);
    assert_eq!(config.parallel_jobs, None); // Auto-detect
    assert!(!config.verbose);
    assert!(!config.dry_run);
}

#[test]
fn boundary_max_parallel_jobs() {
    let mut config = Config::new();
    
    // Test maximum value
    config.set_parallel_jobs(usize::MAX);
    assert_eq!(config.parallel_jobs, Some(usize::MAX));
    
    // Serialize should handle it
    let serialized = toml::to_string(&config).unwrap();
    let deserialized: Config = toml::from_str(&serialized).unwrap();
    assert_eq!(deserialized.parallel_jobs, Some(usize::MAX));
}

#[test]
fn boundary_zero_parallel_jobs() {
    let mut config = Config::new();
    
    // Zero should be valid (interpreted as auto)
    config.set_parallel_jobs(0);
    assert_eq!(config.parallel_jobs, Some(0));
}

#[test]
fn boundary_empty_project() {
    let temp_dir = TempDir::new().unwrap();
    let project_root = temp_dir.path();
    
    // Create absolutely minimal project
    let cargo_toml = r#"
[package]
name = "empty"
version = "0.0.0"
edition = "2021"
"#;
    fs::write(project_root.join("Cargo.toml"), cargo_toml).unwrap();
    
    // No src directory
    let analysis = ProjectAnalysis::analyze(project_root);
    
    // Should handle gracefully
    assert!(analysis.is_err() || analysis.unwrap().code_stats.rust_lines == 0);
}

#[test]
fn boundary_single_line_project() {
    let temp_dir = TempDir::new().unwrap();
    let project_root = temp_dir.path();
    
    let cargo_toml = r#"
[package]
name = "tiny"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(project_root.join("Cargo.toml"), cargo_toml).unwrap();
    
    fs::create_dir_all(project_root.join("src")).unwrap();
    fs::write(project_root.join("src/lib.rs"), "").unwrap(); // Empty file
    
    let analysis = ProjectAnalysis::analyze(project_root).unwrap();
    
    assert_eq!(analysis.code_stats.rust_lines, 0);
    assert_eq!(analysis.code_stats.rust_files, 1);
    assert!(!analysis.complexity.is_complex);
    assert!(!analysis.complexity.is_large_project);
}

#[test]
fn boundary_maximum_string_lengths() {
    let mut config = Config::new();
    
    // Very long flag strings
    let long_flag = "x".repeat(10_000);
    config.extra_cargo_flags.push(long_flag.clone());
    config.extra_rustc_flags.push(format!("-C {}", long_flag));
    
    // Should serialize without panic
    let serialized = toml::to_string(&config).unwrap();
    assert!(serialized.len() > 10_000);
    
    // And deserialize
    let _deserialized: Config = toml::from_str(&serialized).unwrap();
}

#[test]
fn boundary_no_dependencies() {
    let deps = DependencyAnalysis {
        total_dependencies: 0,
        direct_dependencies: 0,
        transitive_dependencies: 0,
        proc_macro_count: 0,
        categories: Default::default(),
        heavy_dependencies: vec![],
        has_heavy_dependencies: false,
        duplicates: vec![],
    };
    
    assert!(!deps.needs_optimization());
}

#[test]
fn boundary_single_dependency() {
    let deps = DependencyAnalysis {
        total_dependencies: 1,
        direct_dependencies: 1,
        transitive_dependencies: 0,
        proc_macro_count: 0,
        categories: Default::default(),
        heavy_dependencies: vec![],
        has_heavy_dependencies: false,
        duplicates: vec![],
    };
    
    assert!(!deps.needs_optimization());
}

#[test]
fn boundary_code_stats_extremes() {
    let mut stats = CodeStats::default();
    
    // Zero everything
    assert_eq!(stats.total_lines, 0);
    assert!(!stats.is_large());
    assert!(!stats.is_test_heavy());
    
    // Maximum values
    stats.rust_lines = usize::MAX;
    stats.test_lines = usize::MAX;
    assert!(stats.is_large());
    assert!(stats.is_test_heavy());
    
    // Test lines > rust lines (edge case)
    stats.rust_lines = 100;
    stats.test_lines = 200;
    assert!(stats.is_test_heavy());
}

#[test]
fn boundary_complexity_score_limits() {
    let metadata = ProjectMetadata {
        name: "test".to_string(),
        version: "0.1.0".to_string(),
        root_path: PathBuf::from("."),
        is_workspace: false,
        workspace_members: vec![],
        cargo_metadata: Default::default(),
    };
    
    // Minimum complexity
    let min_stats = CodeStats::default();
    let min_deps = DependencyAnalysis {
        total_dependencies: 0,
        direct_dependencies: 0,
        transitive_dependencies: 0,
        proc_macro_count: 0,
        categories: Default::default(),
        heavy_dependencies: vec![],
        has_heavy_dependencies: false,
        duplicates: vec![],
    };
    
    let min_complexity = BuildComplexity::calculate(&metadata, &min_stats, &min_deps);
    assert_eq!(min_complexity.score, 0);
    assert!(!min_complexity.is_complex);
    
    // Maximum complexity
    let max_stats = CodeStats {
        total_lines: 1_000_000,
        rust_lines: 1_000_000,
        rust_files: 10_000,
        test_lines: 500_000,
        test_files: 5_000,
        bench_lines: 10_000,
        bench_files: 100,
        example_lines: 10_000,
        example_files: 100,
    };
    
    let max_deps = DependencyAnalysis {
        total_dependencies: 1000,
        direct_dependencies: 300,
        transitive_dependencies: 700,
        proc_macro_count: 100,
        categories: Default::default(),
        heavy_dependencies: vec!["tokio".to_string(); 20],
        has_heavy_dependencies: true,
        duplicates: vec![],
    };
    
    let max_complexity = BuildComplexity::calculate(&metadata, &max_stats, &max_deps);
    assert!(max_complexity.score > 50);
    assert!(max_complexity.score <= 100); // Must be bounded
    assert!(max_complexity.is_complex);
    assert!(max_complexity.is_large_project);
}

#[test]
fn boundary_test_ratio_edge_cases() {
    let metadata = ProjectMetadata {
        name: "test".to_string(),
        version: "0.1.0".to_string(),
        root_path: PathBuf::from("."),
        is_workspace: false,
        workspace_members: vec![],
        cargo_metadata: Default::default(),
    };
    
    let deps = DependencyAnalysis {
        total_dependencies: 0,
        direct_dependencies: 0,
        transitive_dependencies: 0,
        proc_macro_count: 0,
        categories: Default::default(),
        heavy_dependencies: vec![],
        has_heavy_dependencies: false,
        duplicates: vec![],
    };
    
    // No code at all
    let mut stats = CodeStats::default();
    let complexity = BuildComplexity::calculate(&metadata, &stats, &deps);
    assert_eq!(complexity.test_ratio, 0.0);
    
    // Only tests, no production code
    stats.rust_lines = 0;
    stats.test_lines = 1000;
    let complexity = BuildComplexity::calculate(&metadata, &stats, &deps);
    // Should handle division by zero
    assert!(complexity.test_ratio == 0.0 || complexity.test_ratio.is_nan());
    
    // Equal test and production code
    stats.rust_lines = 1000;
    stats.test_lines = 1000;
    let complexity = BuildComplexity::calculate(&metadata, &stats, &deps);
    assert!((complexity.test_ratio - 1.0).abs() < 0.01);
}

#[test]
fn boundary_path_edge_cases() {
    let test_paths = vec![
        PathBuf::from(""),           // Empty path
        PathBuf::from("."),          // Current directory
        PathBuf::from(".."),         // Parent directory
        PathBuf::from("/"),          // Root
        PathBuf::from("//"),         // Double slash
        PathBuf::from("a".repeat(255)), // Maximum filename length
    ];
    
    for path in test_paths {
        // Should handle without panic
        let _ = ProjectAnalysis::analyze(&path);
        let _ = CodeStats::calculate(&path);
        
        let config = Config::new();
        let _ = config.save(&path.join("config.toml"));
    }
}

#[test]
fn boundary_workspace_members() {
    let metadata = ProjectMetadata {
        name: "workspace".to_string(),
        version: "0.1.0".to_string(),
        root_path: PathBuf::from("."),
        is_workspace: false,
        workspace_members: vec![],
        cargo_metadata: Default::default(),
    };
    
    // No members
    assert!(!metadata.is_workspace);
    
    // Single member (not really a workspace)
    let mut metadata = metadata;
    metadata.workspace_members = vec!["single".to_string()];
    metadata.is_workspace = false;
    assert!(!metadata.is_workspace);
    
    // Many members
    metadata.workspace_members = (0..1000).map(|i| format!("member_{}", i)).collect();
    metadata.is_workspace = true;
    assert!(metadata.is_workspace);
    assert_eq!(metadata.workspace_members.len(), 1000);
}

#[test]
fn boundary_cpu_cores() {
    // Mock extreme CPU configurations
    let mut cpu = CpuInfo {
        logical_cores: 1,
        physical_cores: 1,
        model_name: "Single Core".to_string(),
        base_frequency: Some(100),
        max_frequency: Some(100),
        features: vec![],
    };
    
    // Single core
    assert_eq!(cpu.logical_cores, 1);
    assert_eq!(cpu.physical_cores, 1);
    
    // Many cores
    cpu.logical_cores = 256;
    cpu.physical_cores = 128;
    assert!(cpu.logical_cores >= cpu.physical_cores);
    
    // Edge case: logical < physical (shouldn't happen but handle gracefully)
    cpu.logical_cores = 4;
    cpu.physical_cores = 8;
    // System should handle this inconsistency
}

#[test]
fn boundary_memory_sizes() {
    // Test extreme memory configurations
    let mut memory = MemoryInfo {
        total_bytes: 0,
        available_bytes: 0,
        swap_total_bytes: 0,
        swap_available_bytes: 0,
    };
    
    // No memory (impossible but handle it)
    assert_eq!(memory.total_gb(), 0);
    assert_eq!(memory.usage_percent(), 0);
    
    // Minimum viable memory
    memory.total_bytes = 1024 * 1024; // 1MB
    memory.available_bytes = 512 * 1024; // 512KB
    assert!(memory.available_bytes <= memory.total_bytes);
    
    // Maximum memory
    memory.total_bytes = usize::MAX;
    memory.available_bytes = usize::MAX / 2;
    assert!(memory.available_bytes <= memory.total_bytes);
}

#[test]
fn boundary_optimization_feature_combinations() {
    // Test all features disabled
    let config = Config {
        optimization_level: OptimizationLevel::Custom,
        auto_detect_hardware: false,
        analyze_project: false,
        optimize_linker: false,
        enable_cache: false,
        parallel_jobs: None,
        custom_linker: None,
        incremental: false,
        split_debuginfo: false,
        target_cpu: None,
        extra_cargo_flags: vec![],
        extra_rustc_flags: vec![],
        verbose: false,
        dry_run: false,
    };
    
    // Should still be valid
    let serialized = toml::to_string(&config).unwrap();
    let _deserialized: Config = toml::from_str(&serialized).unwrap();
    
    // Test all features enabled
    let mut config = Config::new();
    config.optimization_level = OptimizationLevel::Aggressive;
    config.auto_detect_hardware = true;
    config.analyze_project = true;
    config.optimize_linker = true;
    config.enable_cache = true;
    config.parallel_jobs = Some(64);
    config.incremental = true;
    config.split_debuginfo = true;
    config.verbose = true;
    config.dry_run = false; // Can't have both dry_run and actual execution
    
    let serialized = toml::to_string(&config).unwrap();
    let _deserialized: Config = toml::from_str(&serialized).unwrap();
}

#[test]
fn boundary_empty_flags_vectors() {
    let config = Config::new();
    
    // Empty vectors should be valid
    assert!(config.extra_cargo_flags.is_empty());
    assert!(config.extra_rustc_flags.is_empty());
    
    // Should serialize as empty arrays
    let serialized = toml::to_string(&config).unwrap();
    assert!(serialized.contains("extra_cargo_flags = []") || 
           !serialized.contains("extra_cargo_flags")); // May be omitted
}

#[test]
fn boundary_unicode_in_paths() {
    let temp_dir = TempDir::new().unwrap();
    
    // Create paths with Unicode characters
    let unicode_paths = vec![
        "é¡¹ç›®",     // Chinese
        "Ð¿Ñ€Ð¾ÐµÐºÑ‚",   // Russian  
        "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ", // Japanese
        "ðŸ¦€-rust",  // Emoji
    ];
    
    for name in unicode_paths {
        let project_dir = temp_dir.path().join(name);
        fs::create_dir_all(&project_dir).unwrap();
        
        let cargo_toml = format!(r#"
[package]
name = "{}"
version = "0.1.0"
edition = "2021"
"#, name.replace('ðŸ¦€', "crab")); // Package names have restrictions
        
        fs::write(project_dir.join("Cargo.toml"), cargo_toml).unwrap();
        fs::create_dir_all(project_dir.join("src")).unwrap();
        fs::write(project_dir.join("src/lib.rs"), "// Test\n").unwrap();
        
        // Should handle Unicode paths
        let _ = ProjectAnalysis::analyze(&project_dir);
    }
}

#[test]
fn boundary_version_strings() {
    let versions = vec![
        "0.0.0",
        "0.0.1",
        "1.0.0",
        "999.999.999",
        "0.1.0-alpha",
        "1.0.0-beta.1",
        "2.0.0+build.123",
    ];
    
    for version in versions {
        let metadata = ProjectMetadata {
            name: "test".to_string(),
            version: version.to_string(),
            root_path: PathBuf::from("."),
            is_workspace: false,
            workspace_members: vec![],
            cargo_metadata: Default::default(),
        };
        
        assert_eq!(metadata.version, version);
    }
}

#[test]
fn boundary_float_precision() {
    // Test floating point edge cases
    let ratios = vec![
        0.0,
        0.000001,
        0.5,
        0.999999,
        1.0,
        f32::MIN_POSITIVE,
        f32::MAX,
    ];
    
    for ratio in ratios {
        let complexity = BuildComplexity {
            score: 50,
            is_large_project: false,
            is_complex: false,
            estimated_build_time: 100,
            test_ratio: ratio,
            factors: vec![],
        };
        
        // Should handle all float values
        assert!(complexity.test_ratio >= 0.0 || complexity.test_ratio.is_nan());
    }
}
